using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using Algorithms.Helpers;

namespace Algorithms.ProjectEuler10_99
{
    public static class _12HighlyDivisibleTriangularNumber
    {
        //The sequence of triangle numbers is generated by adding the natural numbers.So the 7th triangle number would be 1 + 2 + 3 + 4 + 5 + 6 + 7 = 28. The first ten terms would be:

        //1, 3, 6, 10, 15, 21, 28, 36, 45, 55, ...
        //Let us list the factors of the first seven triangle numbers:

        //1: 1
        //3: 1,3
        //6: 1,2,3,6
        //10: 1,2,5,10
        //15: 1,3,5,15
        //21: 1,3,7,21
        //28: 1,2,4,7,14,28
        //We can see that 28 is the first tri`angle number to have over five divisors.

        //    What is the value of the first triangle number to have over five hundred divisors?

        // Gives 76576500 and takes 0.55 seconds
        public static double Execute()
        {
            const int divisorCount = 1000;
            double value = 0;
            double previousTriangleMax = 0;
            
            while (true)
            {
                previousTriangleMax++;
                value += previousTriangleMax;
                var divisors = 2;

                // Skip if not divisible by 2
                if (Math.Abs(value % 10) > double.Epsilon) continue;

                // Get all primes less than value
                var root = Math.Sqrt(value);

                for (var i = 2; i <= root; i ++)
                {
                    if (!(Math.Abs(value % i) < double.Epsilon)) continue;
                    divisors += 2;
                }

                //If sqrt is whole add to divisors
                if (Math.Abs(Math.Floor(root) - root) < double.Epsilon) divisors++;

                if (divisors >= divisorCount)
                    return value; 
            }
        }

        // Gives 76576500 and takes 1.3 seconds
        public static double FirstRun()
        {
            const int divisorCount = 1000;
            double value = 0;
            double previousTriangleMax = 0;

            var divisors = new HashSet<double>();
            var maxDivisors = new HashSet<double>();

            while (true)
            {
                previousTriangleMax++;
                value += previousTriangleMax;
                divisors.Clear();

                // Skip if not divisible by 2
                if (Math.Abs(value % 10) > double.Epsilon) continue;

                divisors.Add(1);
                divisors.Add(value);

                // Get all primes less than value
                var root = Math.Sqrt(value);

                //If sqrt is whole add to divisors
                if (Math.Abs(Math.Floor(root) - root) < double.Epsilon) divisors.Add(root);

                var primes = PrimeHelper.GetAllPrimesLessThanValue(Math.Ceiling(root));
                foreach (var prime in primes)
                {
                    for (var i = prime; i <= root; i += prime)
                    {
                        if (!(Math.Abs(value % i) < double.Epsilon)) continue;

                        divisors.Add(i);
                        divisors.Add(value / i);
                    }
                }

                if (divisors.Count > maxDivisors.Count)
                {
                    var array = new double[divisors.Count];
                    divisors.CopyTo(array);
                    maxDivisors = array.ToHashSet();
                }

                if (divisors.Count >= divisorCount)
                    return value;
            }
        }
    }
}
